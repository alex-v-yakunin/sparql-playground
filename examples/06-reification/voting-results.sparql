# Voting Results on ADRs
#
# Analyze how the team voted on architectural decisions.
#
# Expected result: 1 ADR with voting results (ADR-001: 75% for)
# Execution time: < 1 second

PREFIX : <http://example.org/adr#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

SELECT ?adrLabel ?votesFor ?votesAgainst ?totalVotes ?approvalRate
WHERE {
    ?statement a rdf:Statement ;       # Find reified statement
               rdf:subject ?adr ;      # About which ADR
               rdf:predicate :hasStatus ; # Predicate: status
               rdf:object :Accepted ;     # Object: accepted
               :votingResult ?voting .    # Voting result (blank node)
    
    ?voting :votesFor ?votesFor ;      # Votes "for"
            :votesAgainst ?votesAgainst . # Votes "against"
    
    ?adr rdfs:label ?adrLabel .        # ADR label
    
    BIND(?votesFor + ?votesAgainst AS ?totalVotes)  # Calculate total count
    BIND(?votesFor * 100.0 / ?totalVotes AS ?approvalRate) # Calculate approval percentage
}
ORDER BY DESC(?approvalRate)           # Sort from highest to lowest

# Explanation:
# Demonstrates complex metadata through reification and blank nodes.
# ?voting - anonymous node (blank node) with detailed voting data.
# BIND creates computed variables (?totalVotes, ?approvalRate).
# Critical for democratic decision-making processes.
# In SQL: voting_results table with subqueries and computed fields.
# In Property Graph: nested properties or linked meta-nodes.
# In RDF: natural modeling through reification and blank nodes.
